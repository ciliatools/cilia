#!/usr/bin/env bash
# This file is part of Cilia.
# 
# Copyright (C) 2016  Mikael Brockman
# 
# This program is free software: you can redistribute it and/or modify
# it under the terms of the GNU Affero General Public License as
# published by the Free Software Foundation, either version 3 of the
# License, or (at your option) any later version.
# 
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU Affero General Public License for more details.
# 
# You should have received a copy of the GNU Affero General Public License
# along with this program.  If not, see <http://www.gnu.org/licenses/>.


# This script does the work for building and testing a specific commit.
# It should correctly handle aborted previous runs.
# It is extensively commented for clarity.

set -e # fail on error
set -x # print debug trace
set -u # disallow undeclared variable use

TEST="$1" HASH="$2"

SHORTHASH=$(echo $HASH | head -c 8)
CILIA=$(pwd)

# The standard Cilia directory structure.
PROJECT="$ROOT/projects/$ID"
CLONE="$PROJECT/clone"
COMMITS="$PROJECT/commits"
COMMIT="$COMMITS/$HASH"
PROGRESS="$PROJECT/runs/$HASH"
ARTIFACTS="$TMP_ARTIFACTS/$HASH"

# Ensure the existence of the new checkout's parent directory.
mkdir -p "$COMMITS"

# If the commit hasn't been checked out already...
if [ ! -d "$COMMIT" ]; then

  # Create a new Git worktree based on the existing clone,
  # and initialize it to the given branch.
  git --git-dir="$CLONE/.git" worktree add \
    -B "$HASH-cilia" "$COMMIT" "$BRANCH"

fi

# Now reset that worktree to the exact commit we want to test.
cd "$COMMIT"; git reset --hard "$HASH"

# Create the run directory.
mkdir -p "$PROGRESS"

# Handle previous run...
if [ -e "$PROGRESS"/status ]; then
  status=`cat "$PROGRESS"/status`

  if [ "$status" == running ]; then

    # It should be running, but is the pid file there?
    if [ -e "$PROGRESS"/pid ]; then

      if [ ! -e /proc/`cat "$PROGRESS"/pid` ]; then
        # It should be running, but the job probably died.
        # Remove the status file and continue.
        rm "$PROGRESS"/status

      else
        # It's probably actually running.
        exit 0
      fi

    else
      # No pid file, so there is probably something wrong.
      rm "$PROGRESS"/status
    fi

  else # It has a finished status; just skip it.
    exit 0
  fi
fi

# Nuke any other stale progress data.
rm -f "$PROGRESS"/*

if [ ! -f .cilia ] || [ `cat .cilia` != "server" ]; then
  echo skip > "$PROGRESS/status"
  exit
fi

# Enable job control to prevent background subshells
# from being killed immediately when the worker is
# killed; we want to kill it ourselves.
set -m

# Make sure we use a unique Docker Compose project name.
export COMPOSE_PROJECT_NAME="ci$SHORTHASH"

# Run the subcommand.
stdbuf -o 0 "$CILIA"/interleave-fds "$PROGRESS/log" "$TEST" &

# Save the pid of the background subshell.
pid=$!
echo $pid > "$PROGRESS/pid"

# Make sure other workers know we're working on this.
date +%s > "$PROGRESS/started"
echo running > "$PROGRESS/status"

# Define what to do when the subcommand has exited.
function finish {

  # Look for artifacts.
  if [ -d "$ARTIFACTS" -a "$(ls -A $ARTIFACTS)" ]; then
    mkdir -p "$PROGRESS"/artifacts
    cp "$ARTIFACTS"/* "$PROGRESS"/artifacts
  fi
  
  # Clean up.
  rm "$PROGRESS/pid"

  date +%s > "$PROGRESS/finished"
}

# If the worker terminates, quit the subcommand first.
trap down EXIT
function down {
  echo Killing and waiting for $pid...
  kill $pid || true
  wait $pid || true
  echo cancelled > "$PROGRESS/status"
  finish
}

# Wait for it to exit by itself.
if wait
then echo succeeded > "$PROGRESS/status"
else echo failed    > "$PROGRESS/status"
fi

finish
